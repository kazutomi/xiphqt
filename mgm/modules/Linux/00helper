# -*-Perl-*-

# this module is a hack; it isn't a widget builder.  It sits in the background
# and reads /proc/stat for other modules to reduce opens/closes.

# It defines an init method that installs the /proc/stat listener,
# then marks itself 'inactive' so that mgm doesn't try to call _run,
# _update or allocate space.  The last part of the hack is the name
# beginning with 00 so that it loads before the other modules that
# depend on it


package MGMmodule::helperST;
use vars qw(%proc %net $lastmod);

sub module_init{
    my$this=shift;
    my$xclass=$this->{"xclass"};
    my$toplevel=$this->{"toplevel"};
    my$widget=$this->{"widget"};
    
    my$refresh=$widget->optionGet("scalerefresh","");
    
    $lastmod=0;
    $this->module_update;
    $toplevel->repeat($refresh,\&module_update)if(defined(%proc));

    $toplevel->optionAdd("$xclass.active",0,21);
    $this;
}

sub module_instance{
    shift;
}

sub module_update{
    undef $/;
    my$data;
    my$netd;
    if(open(PROC,"/proc/stat")){
	if(open(NET,"/proc/net/dev")){
	    $data=<PROC>;
	    $netd=<NET>;
	    close NET;
	    close PROC;
	    map{
		my$pos=rindex $_, ":";
		if($pos>0){
		    my$key=substr $_,0,$pos;
		    $key=~s/^\s*(\S+)/$1/;
		    $net{$key}=substr $_, $pos+1;
		}
	    } split "\n", $netd;
	}else{
	    $data=<PROC>;
	    close PROC;
	}
    }
    $/="\n";

    map{
	m/^(\S+)\s*(.*)/;
	$proc{$1}=$2;
    } split "\n", $data;

    # what a great hack
    $proc{"cpu"}=~m/(\d+)\s+(\d+)\s+(\d+)\s+(\d+)/;
    $lastmod=$1+$2+$3+$4; # 100ths of a second
}

bless {};
