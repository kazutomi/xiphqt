# -*-Perl-*-

# instances allowed: one 

# (single instance modules would be silly to use more than one of
# anyway, so we use package local storage.  This is faster and places
# less artificial load on the machine than doing everything through
# the object hash)

package MGMmodule::battery;
use Socket;
use vars qw(@state $lstate $graph $widget $xpath $openp $batteries);

sub module_init{
    my$this=shift;
    my$xclass=$this->{"xclass"};
    my$toplevel=$this->{"toplevel"};


    my$test=$this->read_proc;
    if(!defined($test)){
	$toplevel->optionAdd("$xclass.active",        'false',21);      
    }else{
	if($test=~/,/){
	    $batteries=2;
	}else{
	    $batteries=1;
	}
    }
    $toplevel->optionAdd("$xclass.order",201,21);      
    $this;
}

sub module_instance{
    my$this=shift;
    my$toplevel=$this->{"toplevel"};
    return undef if(defined($xpath));
    $xpath=$this->{"xpath"};

    # modify defaults
    $toplevel->optionAdd("$xpath.order",201,21); # status group
    $toplevel->optionAdd("$xpath.scalerefresh",10000,21); # 10s
    $toplevel->optionAdd("$xpath.scalereturn" ,1,21);     # don't need hyst

    if($batteries==1){
	$toplevel->optionAdd("$xpath*label", "battery",21);
	$toplevel->optionAdd("$xpath*lowlabel", "battery low",21);
    }else{
	for(my$i=0;$i<$batteries;$i++){
	    $toplevel->optionAdd("$xpath*$i.label", "battery$i",21);
	    $toplevel->optionAdd("$xpath*$i.lowlabel", "battery$i low",21);
	}
    }

    $toplevel->optionAdd("$xpath.scalewidadj", 80*$batteries,21);  # narrower
    $toplevel->optionAdd("$xpath.scalelenadj", 100,21);

    my$fg=&main::moption($this,"litforeground");
    $toplevel->optionAdd("$xpath*midforeground", $fg,21);
    $toplevel->optionAdd("$xpath*litbackground", '#60c060',21);
    $toplevel->optionAdd("$xpath*midbackground", '#d0d060',21);
    $toplevel->optionAdd("$xpath*lowbackground", '#ff4040',21);
    $toplevel->optionAdd("$xpath*lowforeground", '#ffffff',21);

    my($minx,$miny)=&MGM::Graph::calcxysize($this,100,'%',$batteries);
    $toplevel->optionAdd("$xpath.minx",        $minx,21);      
    $toplevel->optionAdd("$xpath.miny",        $miny,21);      
    $this;
}

sub module_run{
    my$this=shift;
    
    $graph=MGM::Graph->new($this,num=>$batteries,fixed=>1,rangesetting=>100,
			   rangecurrent=>100,minscale=>0,
			   prompt=>'%');

    # color change hack
    @state=map{0}(1...$batteries);
    $lstate=0;
    $this->module_update;
    $graph->{"widget"};        # must return the widget
}

my @pmulist=("Unknown",
	     "Unknown",
	     "Unknown",
	     "Unknown",
	     "Unknown",
	     "Unknown",
	     "Unknown",
	     "Unknown",
	     "Unknown",
	     "2400/3400/3500",
	     "G3/Wallstreet",
	     "G3/Lombard",
	     "G4/NewWorld/iBook",
	     "newer than Titanium");

sub read_proc{
    my$test;
    my$this=shift;

    if($openp){return $this->read_proc_mac;}
    $test=$this->read_proc_apm;
    if(defined($test)){return $test;}
    return $this->read_proc_mac;
}

# Mac style power management
sub read_proc_mac{
    my $percent;
    my $line;

    # get a connection to pmud if we don't have one
    if(!$openp){
	my $iaddr = inet_aton('localhost');
	my $port = 879;
	my $paddr = sockaddr_in($port,$iaddr);
	
	my $proto = getprotobyname('tcp');
	
	if(socket(B_FD, PF_INET, SOCK_STREAM, $proto)){
	    if(connect(B_FD, $paddr)){
		# pmud gives back the raw power status; the status is different
		# for different powerbooks (grumble, grumble)
		sysread B_FD,$_,1024;
		if(m/^\S+\s+\S+\s+(\S+)/){
		  SWITCH:{
		      if($1>=10 && $1<=12){
			  $openp=$1;
			  my$foo="\n";
			  syswrite B_FD,$foo,1;
			  last SWITCH;
		      }
		      print "PowerMac PMU version $1 (".
			  $pmulist[$1].
			      ") not supported yet.\n";
		      close B_FD;
		  }
		} 
	    }
	}
    }
    
    if($openp){
	if($openp>=10 && $openp<=12){
	    sysread B_FD,$line,1024;
	    $line=~m/^S\s+\{([^\}]*)\}\s+\{([^\}]*)\}/;
	    my$l=$1;
	    my$r=$2;
	    
	    my($lac,$lcharge,$lbatt,$lcurrent,$lvoltage)=
		split ' ',$l;
	    my($rac,$rcharge,$rbatt,$rcurrent,$rvoltage)=
		split ' ',$r;
	    
	    $percent= ($lcharge*1000.0 / $lbatt)/10.
		if(defined $lcurrent);
	    $percent.=","
		if(defined ($percent) && defined ($rcurrent));
	    $percent.= ($rcharge*1000.0 / $rbatt)/10.
		if(defined $rcurrent);
	    
	    my$foo="\n";
	    syswrite B_FD,$foo,1;
	}
    }
    $percent;
}

# PC style power management.  Of course they're not the same
# interface.  This is linux.
sub read_proc_apm{
    my$this=shift;
    my$percent;

    if(open(PROC,"/proc/apm")){
	sysread PROC,$_,1024;
	if(m/^\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+([^ \%]+)\%/){
	    $percent=$1;
	}
	close PROC;
    }
    $percent;
}

sub module_update{ 
    my$this=shift;
    my$toplevel=$this->{"toplevel"};
    my$percent;
    my$maxpercent=-1;
    my$i=0;
    my@percentlist=split ",",$this->read_proc;
    foreach $percent (@percentlist){
	# apm, for some reason, seems to occasionally return -1/1.
	# guard against that
	if($percent>=0){
	    $maxpercent=$percent if($maxpercent<$percent);
	}

	if($percent<30){
	    if($percent<8){
		if($state[$i]!=2){
		    $graph->
			barconfigure($i,'aforeXr'=>'lowforeground',
				     'abackXr'=>'lowbackground',
				     'labelXr'=>'lowlabel');
		    $state[$i]=2;
		}
	    }else{
		if($state[$i]!=1){
		    $graph->
			barconfigure($i,'aforeXr'=>'midforeground',
				     'abackXr'=>'midbackground',
				     'labelXr'=>'label');
		    $state[$i]=1;
		}
	    }
	}else{
	    if($state[$i]!=0){
		$graph->
		    barconfigure(0,'aforeXr'=>'litforeground',
				 'abackXr'=>'litbackground',
				 'labelXr'=>'label');
		$state[$i]=0;
	    }
	}
	
	$i++;
    }
    $percent=$maxpercent;
    if($percent>=0){
	
	$graph->set(@percentlist);
	
	if($percent<30){
	    # below 30%, it would be nice to unfix the scale so 
	    # the user can see		
	    if($percent<8){
		if($lstate!=2){
		    $graph->configure(fixed=>0,rangesetting=>8);
		    $lstate=2;
		}
	    }else{
		if($lstate!=1){
		    $graph->configure(fixed=>0,rangesetting=>32);
		    $lstate=1;
		}
	    }
	}else{
	    if($lstate!=0){
		$graph->configure(fixed=>1,rangesetting=>100);
		$lstate=0;
	    }
	}
    }
}

sub destroy{
    close B_FD if($openp);
    $openp=0;
    undef $xpath;
}

bless {};

